<!doctype html>
<html lang="el">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Σκάκι — Απλό HTML</title>
  <style>
    :root{
      --light:#f0d9b5;
      --dark:#b58863;
      --accent:#ffdd57;
      --board-size: 560px;
      --square-size: calc(var(--board-size) / 8);
    }
    body{
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      display:flex;
      gap:28px;
      align-items:flex-start;
      justify-content:center;
      padding:28px;
      background: #f7f7f8;
      color:#222;
    }
    .container{
      display:flex;
      gap:20px;
      align-items:flex-start;
    }
    .board {
      width:var(--board-size);
      height:var(--board-size);
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      border: 6px solid #333;
      box-shadow: 0 8px 18px rgba(0,0,0,0.15);
    }
    .square {
      width:var(--square-size);
      height:var(--square-size);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: calc(var(--square-size) * 0.65);
      cursor: pointer;
      user-select: none;
      position:relative;
      transition: background 120ms;
    }
    .square.light { background: var(--light); }
    .square.dark { background: var(--dark); color:white; }
    .square .dot {
      position:absolute;
      width:18px;
      height:18px;
      border-radius:50%;
      background: rgba(0,0,0,0.18);
      display:none;
    }
    .square.moveTarget .dot { display:block; background: rgba(0,0,0,0.18); }
    .square.captureTarget .dot { display:block; background: rgba(200,30,30,0.9); transform: scale(1.05); }
    .square.selected { box-shadow: inset 0 0 0 3px var(--accent); }
    .controls {
      width:300px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .controls h2 { margin:0 0 6px 0; font-size:18px; }
    button { padding:8px 12px; border-radius:8px; border:1px solid #bbb; background:#fff; cursor:pointer; }
    .moves {
      background:#fff;
      border:1px solid #ddd;
      padding:10px;
      border-radius:8px;
      max-height:360px;
      overflow:auto;
      font-family: monospace;
    }
    .status { font-weight:600; margin-bottom:6px; }
    .small { font-size:13px; color:#555; }
    footer { margin-top:10px; font-size:13px; color:#666; }
    @media (max-width:880px){
      body{ padding:12px; }
      .container{ flex-direction:column; align-items:center; }
      .controls{ width:100%; max-width:420px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div>
      <div id="board" class="board" aria-label="Σκακιέρα" role="grid"></div>
      <footer class="small">Κλικ σε κομμάτι → κλικ σε τετράγωνο</footer>
    </div>

    <div class="controls">
      <div>
        <h2>Στάτους</h2>
        <div id="status" class="status">White to move</div>
        <div id="turnInfo" class="small">Ξεκινούν τα λευκά.</div>
      </div>

      <div>
        <button id="resetBtn">Επαναφορά</button>
        <button id="undoBtn">Άκυρο (undo)</button>
      </div>

      <div>
        <h2>Ιστορικό κινήσεων</h2>
        <div id="moves" class="moves"></div>
      </div>
    </div>
  </div>

<script>
/*
  Απλό σκάκι: Board representation, rendering & basic move validation.
  Δεν περιλαμβάνει: έλεγχο για check/checkmate, en-passant, castling.
  Υποστηρίζει: βασικές κινήσεις κομματιών, διπλή κίνηση πιόνι, προαγωγή σε queen.
*/

// Unicode pieces: χρήση μονοσύμβολων για εμφάνιση
const UNICODE = {
  p: "♟", r: "♜", n: "♞", b: "♝", q: "♛", k: "♚",
  P: "♙", R: "♖", N: "♘", B: "♗", Q: "♕", K: "♔"
};

// αρχική θέση (FEN-like simplified)
const START_FEN = [
  ["r","n","b","q","k","b","n","r"],
  ["p","p","p","p","p","p","p","p"],
  [ "","", "","", "","", "",""],
  [ "","", "","", "","", "",""],
  [ "","", "","", "","", "",""],
  [ "","", "","", "","", "",""],
  ["P","P","P","P","P","P","P","P"],
  ["R","N","B","Q","K","B","N","R"]
];

let board = []; // 8x8 array of strings (piece codes) or "" for empty
let selected = null; // {r,c}
let legalTargets = []; // list of {r,c,isCapture}
let turn = "w"; // "w" or "b"
let history = []; // moves history objects for undo

const boardEl = document.getElementById("board");
const statusEl = document.getElementById("status");
const turnInfoEl = document.getElementById("turnInfo");
const movesEl = document.getElementById("moves");
const resetBtn = document.getElementById("resetBtn");
const undoBtn = document.getElementById("undoBtn");

// Helpers
function cloneBoard(b){
  return b.map(row=>row.slice());
}
function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }
function isWhitePiece(p){ return p && p === p.toUpperCase(); }
function isBlackPiece(p){ return p && p === p.toLowerCase(); }
function pieceColor(p){ if(!p) return null; return (p===p.toUpperCase()?"w":"b"); }
function coordToAlg(r,c){ const file = "abcdefgh"[c]; const rank = 8-r; return file + rank; }

// Initialize
function init(){
  board = cloneBoard(START_FEN);
  selected = null;
  legalTargets = [];
  turn = "w";
  history = [];
  render();
  updateStatus();
  movesEl.innerHTML = "";
}
function render(){
  boardEl.innerHTML = "";
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const sq = document.createElement("div");
      sq.className = "square " + (((r+c)%2===0) ? "light":"dark");
      sq.dataset.r = r; sq.dataset.c = c;
      sq.setAttribute("role","gridcell");
      // piece
      const p = board[r][c];
      if(p){
        const span = document.createElement("span");
        span.textContent = UNICODE[p] || p;
        span.title = p;
        sq.appendChild(span);
      }
      // dot for move/capture
      const dot = document.createElement("div");
      dot.className = "dot";
      sq.appendChild(dot);

      // highlight selection or legal targets
      if(selected && selected.r==r && selected.c==c) sq.classList.add("selected");
      const t = legalTargets.find(x=>x.r==r && x.c==c);
      if(t){
        if(t.isCapture) sq.classList.add("captureTarget");
        else sq.classList.add("moveTarget");
      }

      sq.addEventListener("click", onSquareClick);
      boardEl.appendChild(sq);
    }
  }
}

function updateStatus(){
  statusEl.textContent = (turn==="w" ? "White to move" : "Black to move");
  turnInfoEl.textContent = (turn==="w" ? "Σειρά των λευκών" : "Σειρά των μαύρων");
}

// Click handling
function onSquareClick(e){
  const r = parseInt(this.dataset.r,10);
  const c = parseInt(this.dataset.c,10);
  const clickedPiece = board[r][c];

  // If a legal target was clicked, move
  const t = legalTargets.find(x=>x.r==r && x.c==c);
  if(t){
    makeMove(selected.r, selected.c, r, c, t);
    return;
  }

  // otherwise, if clicking a piece of side to move, select it
  if(clickedPiece && pieceColor(clickedPiece) === (turn==="w"?"w":"b")){
    selected = {r,c};
    legalTargets = computeLegalMoves(r,c);
    render();
    return;
  }

  // click empty square that isn't legal target -> clear selection
  selected = null; legalTargets = []; render();
}

// Move generation (basic, no check detection)
function computeLegalMoves(r,c){
  const p = board[r][c];
  if(!p) return [];
  const color = pieceColor(p);
  const dir = (color==="w") ? -1 : 1; // pawn direction (white up)
  const moves = [];

  const add = (rr,cc, isCapture=false) => {
    if(!inBounds(rr,cc)) return;
    const target = board[rr][cc];
    if(isCapture){
      if(target && pieceColor(target) !== color) moves.push({r:rr,c:cc,isCapture:true});
    } else {
      if(!target) moves.push({r:rr,c:cc,isCapture:false});
    }
  };

  const lower = p.toLowerCase();
  if(lower === "p"){ // pawn
    // forward one
    if(!board[r+dir] || true){ } // just to avoid lint
    if(inBounds(r+dir,c) && !board[r+dir][c]) add(r+dir,c,false);
    // forward two from start
    const startRow = (color==="w") ? 6 : 1;
    if(r===startRow && inBounds(r+2*dir,c) && !board[r+dir][c] && !board[r+2*dir][c]) add(r+2*dir,c,false);
    // captures
    if(inBounds(r+dir,c-1) && board[r+dir][c-1] && pieceColor(board[r+dir][c-1]) !== color) add(r+dir,c-1,true);
    if(inBounds(r+dir,c+1) && board[r+dir][c+1] && pieceColor(board[r+dir][c+1]) !== color) add(r+dir,c+1,true);
    // (en-passant not implemented)
  } else if(lower === "n"){ // knight
    const deltas = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
    deltas.forEach(([dr,dc])=>{
      const rr=r+dr, cc=c+dc;
      if(!inBounds(rr,cc)) return;
      if(board[rr][cc]){
        if(pieceColor(board[rr][cc])!==color) moves.push({r:rr,c:cc,isCapture:true});
      } else moves.push({r:rr,c:cc,isCapture:false});
    });
  } else if(lower === "b" || lower === "r" || lower === "q"){
    const dirs = [];
    if(lower === "b" || lower === "q") dirs.push([-1,-1],[-1,1],[1,-1],[1,1]);
    if(lower === "r" || lower === "q") dirs.push([-1,0],[1,0],[0,-1],[0,1]);
    dirs.forEach(([dr,dc])=>{
      let rr=r+dr, cc=c+dc;
      while(inBounds(rr,cc)){
        if(board[rr][cc]){
          if(pieceColor(board[rr][cc])!==color) moves.push({r:rr,c:cc,isCapture:true});
          break;
        } else {
          moves.push({r:rr,c:cc,isCapture:false});
        }
        rr+=dr; cc+=dc;
      }
    });
  } else if(lower === "k"){
    for(let dr=-1; dr<=1; dr++){
      for(let dc=-1; dc<=1; dc++){
        if(dr===0 && dc===0) continue;
        const rr=r+dr, cc=c+dc;
        if(inBounds(rr,cc)){
          if(board[rr][cc]){
            if(pieceColor(board[rr][cc])!==color) moves.push({r:rr,c:cc,isCapture:true});
          } else moves.push({r:rr,c:cc,isCapture:false});
        }
      }
    }
    // (castling not implemented)
  }

  // Filter out moves that would capture own piece (we already avoid that)
  return moves;
}

// Make a move
function makeMove(r1,c1, r2,c2, t){
  const piece = board[r1][c1];
  const captured = board[r2][c2] || null;
  const prevBoard = cloneBoard(board);
  // move piece
  board[r2][c2] = piece;
  board[r1][c1] = "";

  // pawn promotion if reached last rank
  if(piece.toLowerCase()==="p"){
    const lastRow = (piece === piece.toUpperCase()) ? 0 : 7;
    const isWhite = piece === piece.toUpperCase();
    if((isWhite && r2===0) || (!isWhite && r2===7)){
      // simple promotion to Queen
      board[r2][c2] = isWhite ? "Q" : "q";
    }
  }

  // save history for undo
  history.push({
    from:{r:r1,c:c1},
    to:{r:r2,c:c2},
    piece: piece,
    captured: captured,
    prevBoard: prevBoard,
    turnBefore: turn
  });

  // update move list text (algebraic-ish)
  const moveText = coordToAlg(r1,c1) + "-" + coordToAlg(r2,c2) + (captured ? " x" : "");
  appendMove(moveText);

  // switch turn
  turn = (turn==="w") ? "b" : "w";
  selected = null; legalTargets = [];
  render();
  updateStatus();
}

// Append move to the moves box (numbering)
function appendMove(text){
  const moveNumber = Math.floor(history.length/2) + (turn==="b" ? 0 : 1);
  // simple formatting: each history entry is a ply. We'll show moves as lines.
  const line = document.createElement("div");
  const ply = history.length;
  if(ply%2===1){
    // white move, start new line with number
    const num = Math.ceil(ply/2);
    line.textContent = num + ". " + text;
  } else {
    // black move, append to last line
    const last = movesEl.lastElementChild;
    if(last) last.textContent = last.textContent + "    " + text;
    return;
  }
  movesEl.appendChild(line);
  movesEl.scrollTop = movesEl.scrollHeight;
}

// Undo
function undo(){
  if(history.length===0) return;
  const last = history.pop();
  board = last.prevBoard;
  turn = last.turnBefore;
  selected = null; legalTargets = [];
  // remove last move from movesEl
  if(movesEl.lastElementChild){
    if(history.length % 2 === 0){
      // last line was white move only (odd ply)
      movesEl.removeChild(movesEl.lastElementChild);
    } else {
      // last line had both moves, remove appended black move text
      const lastLine = movesEl.lastElementChild;
      if(lastLine){
        // split by multiple spaces we used
        const parts = lastLine.textContent.split("    ");
        if(parts.length>1){
          parts.pop(); // remove black move
          lastLine.textContent = parts.join("    ");
        } else {
          movesEl.removeChild(lastLine);
        }
      }
    }
  }
  render();
  updateStatus();
}

resetBtn.addEventListener("click", init);
undoBtn.addEventListener("click", undo);

// keyboard: ESC clears selection
document.addEventListener("keydown", (e)=>{
  if(e.key === "Escape") { selected=null; legalTargets=[]; render(); }
});

// start
init();
</script>
</body>
</html>
